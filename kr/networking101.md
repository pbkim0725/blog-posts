# 제목: Networking 101

<!-- TODO 서론 입력 해야함 -->

## 인터넷의 작동 원리

혹시 지금 인터넷을 접속할 수 있는 환경이라면 (당연히 접속할 수 있는 환경이시겠죠.), 주소창에 172.217.25.206 이라는 숫자를 복사 붙여넣기로 넣어보시기 바랍니다.
굉장히 친숙한 페이지가 화면에 나오지 않나요? 이 것을 우리는 IP 주소라고 부릅니다. 하지만 이러한 웹사이트들을 접속하기 위해서 반드시 IP 주소를 입력해 들어가야 한다고 생각해봅시다. 정말 끔찍하겠죠? 저 긴 숫자 조합을 외우고 다녀야 될테니까요. 네트워크의 세계에서 마치 사람의 이름처럼, 컴퓨터는 IP라는 고유의 숫자들을 부여받습니다. 숫자로 이름을 부여받는 "컴퓨터적인" 사고에 대한 이질감을 극복하고 더 쉽게 대중들이 이해할 수 있는 시스템이 필요했습니다. 이 필요에 의해 네트워크 엔지니어들은, DNS, 즉 Domain Name System 을 개발하기에 이릅니다. DNS의 역할은 매우 간단합니다. 인간이 알아들을 수 있는 "이름" 을 IP 주소인 "숫자" 로 변환해주는 것 입니다.

이러한 이름이 IP 주소로 변환되는 과정은 생각보다 굉장히 간단합니다. 예를들어 여러분이 주소창에 google.com을 입력한다고 가정해 봅시다. 만약 여러분의 브라우저가 이 주소를 여러분 컴퓨터의 캐시메모리에서 찾지 못한다면, Resolver 서버에 쿼리를 보내게 됩니다. 이 Resolver Server 는 쉽게 말해서, **ISP**, 즉 KT, SKT와 같은 여러분의 인터넷 서비스 제공자라고 생각하시면 됩니다. 이 Resolver 가 쿼리를 받을 때, 서버에 있는 캐시 메모리에서 먼저 google.com의 IP 주소를 찾아보려고 할 것 입니다. 만약 여기서도 이 정보를 찾지 못한다면, Root Server 라고 불리우는 DNS 의 가장 최상위에 위치하는 서버에 쿼리를 할 것 입니다. 이 Root Server 는 전세계에 13 세트만 존재하며, 전 세계 여러 위치에 배치되어 있습니다. 이 Root Server 는 사실 여러분들이 요청한 IP 주소를 알고있지 못합니다. 대신 .com 도메인의 가장 최상단에 위치해 있는 서버인 TLD 서버로 유도합니다. Resolver 서버는 다시 이 TLD 서버에게 IP 요청을 하게 됩니다. 이 TLD 서버는 .com, .net, .org 와 같은 최상위 도메인에 대한 주소값을 보관해 두는데, 이 서버 역시 IP 주소를 알고있지는 못합니다. 최종적으로 TLD 서버는 우리의 요청을 Authoritatve Name Server 라는 모든 도메인 정보를 갖고 있는 서버로 라우트 해주고, 비로서 우리가 요청한 IP 값을 얻게 되는 것 입니다.

<!-- TODO 자 여기까지 우리는 x 를 배웠습니다 -->

![alt](http://drive.google.com/uc?id=1AIUbp_rqGIlmygyQqt0war3aC1BNeC4t)

> 2011년 초, Hibernia Networks사와 중국의 Huawei 는 대서양을 가로질러 4600km 길이의 거대한 해저 케이블 시스템을 구축했습니다. 런던과 뉴욕을 잇는 이 해저 케이블은 5000 억 근처의 시공 비용이 투자 된 거대한 프로젝트 였습니다. 이 해저 케이블의 목적은 단 한가지 였습니다. 런던과 뉴욕간의 금융 거래속도를 단 5 밀리 초를 줄이기 위해 시공된 것 입니다. 이 5 밀리 초라는 체감조차 하기 힘든 짧은 시간은 기존 뉴욕-런던 거래소에서 내던 비용을 무려 초당 약 800억을 절약해줍니다. 이 이야기가 네트워킹이랑 무슨 관련이 있냐구요? 앞으로 이야기 할 주제는 바로 앞서 언급한 5 밀리 초라는 지연 시간, 즉 Latency에 대한 부분이기 때문입니다.

Latency란 출발지에서 부터 목적지 Packet 을 보내는데 걸리는 시간을 의미합니다.

![alt](http://drive.google.com/uc?id=1xZO467PtxlZfVjU0xAFg6jN5CugidWPM)


사실 HTTP는 공식적으로 TCP 프로토콜로만 이루어져야 한다는 언급이 없습니다. 사실 뒤에 자세히 다룰 UDP, User Datagram Protocol과 같은 다른 프토토콜들로 데이터를 주고 받을 수 있습니다. 물론 현실 세계에서의 대부분 HTTP는 TCP가 바탕이 되어있지만요. 


## TCP 

인터넷의 핵심과도 같은 두 프로토콜은 IP 와 TCP 입니다. (TCP/IP) <br />
IP 는 위에서 말했다시피 host 에서 다른 host로 가는 라우팅(routing)과 어드레싱(addressing) 기능을 제공해주며, TCP(Transmission Control Protocol)은 불안정한 통로위에 안정적인 네트워크가 이루어질 수 있도록 만들어줍니다. 1981년, RFC675 라는 하나의 제안서로 시작 된 이 TCP는 몇 가지 보완된 점은 있지만 오늘 날의 웹에서 사용되는 통신 방식입니다. 이러한 TCP는 네트워크에 대한 효율적인 "추상화" 를 제공하는데, 네트워크 커뮤니케이션에 있어서 복잡한 요소들인 잃어버린 데이터에 대한 재전송(retransmission), 정렬된 송신(in-order delivery), congestion control(막힘 제어), congestion avoidance(막힘 회피) 등에 대한 내용을 담고있습니다. 앞서 언급드린 TCP의 데이터 확실성은 브라우저상의 웹 성능을 최적화 시키는데에 대한 몇 가지 장애요소들을 필연적으로 만들게 됩니다. 


### Three-Way Handshake 

모든 TCP 연결은 Three-Way Handshake, 세 방향 악수로 시작합니다. 클라이언트와 서버간의 통신이 시작되기 전, 이 둘은 packet 수열에 각자 동의해야 합니다. 이 수열은 양측 방향에서 임의적으로 선택되는데 다음의 이미지를 참조해주시길 바랍니다. 

**SYN**<br />
클라이언트는 앞서 설명했듯이, 임의적으로 수열 숫자 x 를 만들어서 경우에따라 TCP 스펙상의 플래그와 설정 값을 부여하고 서버로 보냅니다.  

**SYN ACK**<br />
서버는 클라이언트에게 받은 x 숫자를 1 만큼 늘려주고, 자체적으로 플래그와 옵션들이 붙어 있는 'y' 라는 임의적인 수열을 만든 후, 이를 클라이언트에게 되돌려 보냅니다.

**ACK**<br />
클라이언트는 기존의 수열 숫자들인 'x' 와 'y' 를 각각 1 씩 늘려준 뒤, 가장 마지막 순서에 있는 패킷인 ACK를 발송합니다. 

[이미지]

이 세 방향의 동의가 모두 이루어진다면, 드디어 이 둘 사이의 애플리케이션의 데이터가 흐를 수 있게 됩니다. 문제는 각 핸드셰이크가 이루어질 때마다 발생하는 레이턴시 인데, 이러한 지연시간으로 인해 새로운 TCP 연결이 시작되는 것은 부담이 됩니다. 때문에, 이러한 연결을 재사용 하는 것이 TCP위에 작동되는 앱에 대한 최적화를 결정짓는 중요한 요소가 됩니다.  

### Congestion Avoidance & Control 

Congestion Control 은 복잡한 네트워크에 있어 커다란 문제였습니다. 순수 데이터 형태의 프로토콜인 IP 와 전송 레이어 프로토콜인 TCP가 특히 서로 다른 대역폭을 갖고 있을 때 "Congestion Collapse" 라는 것이 발생합니다. 간단하게 요약하자면, 네트워크간의 왕복 횟수가 최대 재전송 주기를 넘어섰을 때 다른 한쪽의 반응이 없어, 중복된 데이터그램을 전송하게 됩니다. 결국 모든 노드의 버퍼 데이터는 최대가 되며, 전송되는 패킷의 양을 줄여야하는 상황이 발생합니다. 네트워크가 무너지지는 않지만, 점점 수용량이 줄어들게 되며 최종적으로는 사용할 수 없는 상태에 이르게 됩니다. 이러한 문제점을 해결하기 위해 TCP 에서 어떠한 데이터들이 양 방향으로 보내질 수 있는지 관리할 수 있도록 다음의 기술들이 적용되게 됩니다: flow control, congestion control, congestion avoidance. 

**Flow Control**

플로우 콘트롤은 수신자가 감당할 수 없을 정도의 많은 데이터를 송신하는 것을 방지하기 위해 만들어졌습니다. TCP 연결의 양측은 receive window (rwnd) 라는 것을 만드는데, 이 것은 서로에게 각측이 갖고 있는 수용 가능한 버퍼 용량의 상태를 알려줄 수 있습니다. 기본적인 메커니즘은 다음과 같습니다. 처음 연결이 발생했을 때, 시스템 설정에 따라 초기 rwnd 값을 갖고 시작합니다. 일반적인 웹 페이지는 서버로부터 클라이언트에게 대부분의 데이터를 송신하게 되는데, 이는 곧 클라이언트 쪽의 윈도우가 바틀넥 현상이 일어나는 상황이 발생하게 됩니다. 만약 클라이언트가 비디오나 이미지를 업로드 하는 등 큰 양의 데이터를 서버쪽으로 보낸다면, 서버의 rwnd가 발목을 붙잡게 됩니다. 

만약 어떠한 이유로든, 한쪽이 다른 한쪽에 맞출 수 없다면, rwnd의 사이즈를 낮출 것을 송신자에게 요청하게 됩니다. 만약 이 사이즈가 0 된다면, 모든 버퍼 데이터가 어플리케이션 레이어상에서 클리어 될 떄 까지 데이터를 송신하지 않습니다. 

**Slow-Start** 

위의 flow control 기능에도 불구하고, ~~
### TCP 최적화 


## UDP 

### UDP 최적화 

## TLS